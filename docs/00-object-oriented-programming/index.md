# 圏論学習ノート (C#)

## イントロダクション: なぜ圏論か？
参考動画: [Category Theory for Programmers: The Preface](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_)

### 1. 並行処理とデータ競合 (Data Race)
現代のハードウェアはマルチコア化が進んでおり、パフォーマンスを引き出すには並行処理（Concurrency）や並列処理（Parallelism）が不可欠です。

> **Note: 並行処理と並列処理の違い**
> *   **並行処理 (Concurrency)**: 複数のタスクを（タイムスライスなどで）切り替えながら、論理的に同時に進行させる構成のこと。
> *   **並列処理 (Parallelism)**: 複数のスレッドを複数のコアやCPUに割り当てて、物理的に同時に実行すること。

しかし、これらには **データ競合 (Data Race)** という大きな問題があります。データ競合は、複数のスレッドが同じメモリ領域に同時にアクセスし、そのうち少なくとも一方が書き込みを行うことで発生します。

### 2. オブジェクト指向 (OOP) の限界
オブジェクト指向プログラミングは、データと振る舞いをオブジェクトにまとめ、内部状態を隠蔽（カプセル化）することで複雑さを管理しようとします。しかし、並行処理の文脈では以下の構造的な弱点があります。

*   **参照の共有 (Shared Pointers)**:
    OOPでは、オブジェクト自体はヒープ上にあり、その「参照（ポインタ）」があちこちで共有されます。
*   **可変な状態 (Mutable State)**:
    メソッドを呼び出すことでオブジェクトの内部状態が書き換わります。

「共有された参照」を通じて「可変な状態」を操作する構造こそが、データ競合の温床です。これを防ぐためにロック (Mutex) を導入すると、今度は「ロックの合成（Composition）」が難しいという問題（デッドロックや複雑性の増大）に直面します。

### 3. 圏論・関数型のアプローチ
圏論的なアプローチ（関数型プログラミング）では、**不変性 (Immutability)** を重視します。
*   データは書き換えられず、常に新しい値が作られる。
*   副作用がないため、競合が起きない。
*   これにより、関数（射）を安全に **合成 (Compose)** することが可能になります。

### 4. 本プロジェクトのアプローチ
C# は純粋な関数型プログラミング言語ではありません。
今回はオブジェクト指向プログラミングをベースとしながらも、できるだけ関数型プログラミングの思想を取り入れ、現実的な実装を試みたいと思います。